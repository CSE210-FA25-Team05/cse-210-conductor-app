'use strict';

/**
 * Lectures Service
 *
 * This module provides business logic for lecture-related operations.
 */

class LecturesService {
  constructor(lecturesRepo, lecturesPermissions) {
    this.lecturesRepo = lecturesRepo;
    this.lecturesPermissions = lecturesPermissions;
  }

  /**
   * Get all lectures for a course with permission check.
   *
   * @param {Object} user - Current user object
   * @param {Object} course - Course object (from req.course)
   * @param {Object|null} enrollment - Enrollment object (from req.enrollment, null if not enrolled)
   * @returns {Promise<Array>} List of lectures
   */
  async getAllLectures(user, course, enrollment) {
    const canView = await this.lecturesPermissions.canViewLectures(
      user,
      course,
      enrollment
    );
    if (!canView) {
      const error = new Error('You are not enrolled in this course');
      error.code = 'FORBIDDEN';
      throw error;
    }

    return await this.lecturesRepo.getLecturesByCourseId(course.id);
  }

  /**
   * Get a single lecture with permission check.
   *
   * @param {Object} user - Current user object
   * @param {Object} course - Course object (from req.course)
   * @param {Object|null} enrollment - Enrollment object (from req.enrollment, null if not enrolled)
   * @param {number} lectureId - ID of the lecture
   * @returns {Promise<Object>} Lecture object
   */
  async getLecture(user, course, enrollment, lectureId) {
    const canView = await this.lecturesPermissions.canViewLectures(
      user,
      course,
      enrollment
    );
    if (!canView) {
      const error = new Error('You are not enrolled in this course');
      error.code = 'FORBIDDEN';
      throw error;
    }

    const lecture = await this.lecturesRepo.getLectureById(
      lectureId,
      course.id
    );
    if (!lecture) {
      const error = new Error('Lecture not found');
      error.code = 'NOT_FOUND';
      throw error;
    }

    return lecture;
  }

  /**
   * Create a new lecture with permission check.
   *
   * @param {Object} user - Current user object
   * @param {Object} course - Course object (from req.course)
   * @param {Object|null} enrollment - Enrollment object (from req.enrollment, null if not enrolled)
   * @param {Object} lectureData - Lecture data
   * @returns {Promise<Object>} Created lecture object
   */
  async createLecture(user, course, enrollment, lectureData) {
    const canModify = await this.lecturesPermissions.canModifyLectures(
      user,
      course,
      enrollment
    );
    if (!canModify) {
      const error = new Error('Only professors and TAs can create lectures');
      error.code = 'FORBIDDEN';
      throw error;
    }

    // Code is auto-generated by the repo if not provided
    return await this.lecturesRepo.createLecture({
      course_id: course.id,
      lecture_date: lectureData.lecture_date,
      code: lectureData.code || null, // If null, repo will auto-generate
    });
  }

  /**
   * Update a lecture with permission check.
   *
   * @param {Object} user - Current user object
   * @param {Object} course - Course object (from req.course)
   * @param {Object|null} enrollment - Enrollment object (from req.enrollment, null if not enrolled)
   * @param {number} lectureId - ID of the lecture
   * @param {Object} updateData - Update data
   * @returns {Promise<Object>} Updated lecture object
   */
  async updateLecture(user, course, enrollment, lectureId, updateData) {
    const canModify = await this.lecturesPermissions.canModifyLectures(
      user,
      course,
      enrollment
    );
    if (!canModify) {
      const error = new Error('Only professors and TAs can update lectures');
      error.code = 'FORBIDDEN';
      throw error;
    }

    const existingLecture = await this.lecturesRepo.getLectureById(
      lectureId,
      course.id
    );
    if (!existingLecture) {
      const error = new Error('Lecture not found');
      error.code = 'NOT_FOUND';
      throw error;
    }

    if (
      !updateData.lecture_date &&
      updateData.code === undefined &&
      updateData.regenerate_code !== true
    ) {
      return existingLecture;
    }

    const finalUpdateData = {
      lecture_date: updateData.lecture_date || existingLecture.lecture_date,
      code: updateData.code,
      regenerate_code: updateData.regenerate_code,
      course_id: course.id, // Required for code regeneration
    };

    return await this.lecturesRepo.updateLecture(lectureId, finalUpdateData);
  }

  /**
   * Delete a lecture with permission check.
   *
   * @param {Object} user - Current user object
   * @param {Object} course - Course object (from req.course)
   * @param {Object|null} enrollment - Enrollment object (from req.enrollment, null if not enrolled)
   * @param {number} lectureId - ID of the lecture
   * @returns {Promise<void>}
   */
  async deleteLecture(user, course, enrollment, lectureId) {
    const canModify = await this.lecturesPermissions.canModifyLectures(
      user,
      course,
      enrollment
    );
    if (!canModify) {
      const error = new Error('Only professors and TAs can delete lectures');
      error.code = 'FORBIDDEN';
      throw error;
    }

    const existingLecture = await this.lecturesRepo.getLectureById(
      lectureId,
      course.id
    );
    if (!existingLecture) {
      const error = new Error('Lecture not found');
      error.code = 'NOT_FOUND';
      throw error;
    }

    await this.lecturesRepo.deleteLecture(lectureId);
  }
}

module.exports = LecturesService;
